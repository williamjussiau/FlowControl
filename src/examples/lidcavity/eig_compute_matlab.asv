function S = load_sparse_from_python(matfilename, varprefix)
% LOAD_SPARSE_FROM_PYTHON Load a sparse matrix saved in CSR format from Python
%
% Inputs:
%   matfilename - string, path to the .mat file (e.g., 'E_sparse.mat')
%   varprefix   - string, prefix used for variable names in the mat file (e.g., 'E')
%
% Output:
%   S - MATLAB sparse matrix reconstructed

    % Load variables
    data = load(matfilename, [varprefix '_data']);
    indices = load(matfilename, [varprefix '_indices']);
    indptr = load(matfilename, [varprefix '_indptr']);
    shape = load(matfilename, [varprefix '_shape']);
    
    data = data.([varprefix '_data']);
    indices = indices.([varprefix '_indices']);
    indptr = indptr.([varprefix '_indptr']);
    shape = shape.([varprefix '_shape']);
    
    % Convert all to double (MATLAB indexing, logical, and sparse require doubles)
    data = double(data);
    indices = double(indices);
    indptr = double(indptr);
    shape = double(shape);
    
    % Number of rows and cols
    nrows = shape(0+1);  % Python is 0-based, MATLAB 1-based indexing, just regular indexing here
    ncols = shape(1+1);
    
    % Reconstruct row indices from indptr (CSC format) to row and col indices:
    % Note: Python CSR = Compressed Sparse Row format
    %   indptr: length = nrows+1, indices: column indices for nonzeros, data = values
    % MATLAB sparse requires (row, col, value)
    % So:
    %   For each row r:
    %       col = indices[indptr[r]:indptr[r+1]-1]
    %       val = data[indptr[r]:indptr[r+1]-1]
    %       row = r for these entries
    
    % Build vectors for rows, columns, and values
    rows = zeros(length(data), 1);
    cols = zeros(length(data), 1);
    
    % Populate rows and cols
    idx = 1;
    for r = 1:nrows
        start_ind = indptr(r) + 1;  % +1 for MATLAB indexing
        end_ind = indptr(r+1);
        count = end_ind - start_ind + 1;
        if count > 0
            rows(idx:idx+count-1) = r;
            cols(idx:idx+count-1) = indices(start_ind:end_ind) + 1;  % +1 for MATLAB indexing
            idx = idx + count;
        end
    end
    
    % Construct sparse matrix
    S = sparse(rows, cols, data, nrows, ncols);
end


A = load_sparse_from_python('data_output/operators/A_sparse.mat', 'A');
E = load_sparse_from_python('data_output/operators/E_sparse.mat', 'E');
%%
neig = 10;          % number of eigenvalues per shift
opts.tol = 1e-8;
opts.maxit = 1000;

% Frequencies to scan along imaginary axis
omega_list = linspace(0, 50, 20);  % from 0 to 50 in 20 steps

all_lambda = [];  % store eigenvalues found

for omega = omega_list
    target = 1i * omega;  % shift along imaginary axis
    try
        [~, vals] = eigs(A, E, neig, target, opts);
        lambda = diag(vals);
        all_lambda = [all_lambda; lambda];  %#ok<AGROW>
    catch ME
        warning('eigs failed for omega = %f + %fi\n%s', real(target), imag(target), ME.message);
    end
end

% Remove duplicates within tolerance (optional)
all_lambda = unique(all_lambda);

% Plot all collected eigenvalues on complex plane
figure;
plot(real(all_lambda), imag(all_lambda), 'bo', 'MarkerSize', 8, 'LineWidth', 1.5);
grid on;
xlabel('Real Part');
ylabel('Imaginary Part');
title('Eigenvalues near imaginary axis from multiple shifts');
axis equal;
hold on;
plot(xlim, [0 0], 'k--'); % horizontal zero line
plot([0 0], ylim, 'k--'); % vertical zero line
hold off;
